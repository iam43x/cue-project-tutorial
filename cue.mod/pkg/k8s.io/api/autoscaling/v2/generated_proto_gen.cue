//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//

// This file was autogenerated by go-to-protobuf. Do not edit it manually!
package v2

import (
	"k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/api/resource"
)

// ContainerResourceMetricSource indicates how to scale on a resource metric known to
// Kubernetes, as specified in requests and limits, describing each pod in the
// current scale target (e.g. CPU or memory).  The values will be averaged
// together before being compared to the target.  Such metrics are built in to
// Kubernetes, and have special scaling options on top of those available to
// normal per-pod metrics using the "pods" source.  Only one "target" type
// should be set.
#ContainerResourceMetricSource: {
	// name is the name of the resource in question.
	name?: string @protobuf(1,string)

	// target specifies the target value for the given metric
	target?: #MetricTarget @protobuf(2,MetricTarget)

	// container is the name of the container in the pods of the scaling target
	container?: string @protobuf(3,string)
}

// ContainerResourceMetricStatus indicates the current value of a resource metric known to
// Kubernetes, as specified in requests and limits, describing a single container in each pod in the
// current scale target (e.g. CPU or memory).  Such metrics are built in to
// Kubernetes, and have special scaling options on top of those available to
// normal per-pod metrics using the "pods" source.
#ContainerResourceMetricStatus: {
	// name is the name of the resource in question.
	name?: string @protobuf(1,string)

	// current contains the current value for the given metric
	current?: #MetricValueStatus @protobuf(2,MetricValueStatus)

	// container is the name of the container in the pods of the scaling target
	container?: string @protobuf(3,string)
}

// CrossVersionObjectReference contains enough information to let you identify the referred resource.
#CrossVersionObjectReference: {
	// kind is the kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind?: string @protobuf(1,string)

	// name is the name of the referent; More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	name?: string @protobuf(2,string)

	// apiVersion is the API version of the referent
	// +optional
	apiVersion?: string @protobuf(3,string)
}

// ExternalMetricSource indicates how to scale on a metric not associated with
// any Kubernetes object (for example length of queue in cloud
// messaging service, or QPS from loadbalancer running outside of cluster).
#ExternalMetricSource: {
	// metric identifies the target metric by name and selector
	metric?: #MetricIdentifier @protobuf(1,MetricIdentifier)

	// target specifies the target value for the given metric
	target?: #MetricTarget @protobuf(2,MetricTarget)
}

// ExternalMetricStatus indicates the current value of a global metric
// not associated with any Kubernetes object.
#ExternalMetricStatus: {
	// metric identifies the target metric by name and selector
	metric?: #MetricIdentifier @protobuf(1,MetricIdentifier)

	// current contains the current value for the given metric
	current?: #MetricValueStatus @protobuf(2,MetricValueStatus)
}

// HPAScalingPolicy is a single policy which must hold true for a specified past interval.
#HPAScalingPolicy: {
	// type is used to specify the scaling policy.
	type?: string @protobuf(1,string)

	// value contains the amount of change which is permitted by the policy.
	// It must be greater than zero
	value?: int32 @protobuf(2,int32)

	// periodSeconds specifies the window of time for which the policy should hold true.
	// PeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).
	periodSeconds?: int32 @protobuf(3,int32)
}

// HPAScalingRules configures the scaling behavior for one direction.
// These Rules are applied after calculating DesiredReplicas from metrics for the HPA.
// They can limit the scaling velocity by specifying scaling policies.
// They can prevent flapping by specifying the stabilization window, so that the
// number of replicas is not set instantly, instead, the safest value from the stabilization
// window is chosen.
#HPAScalingRules: {
	// stabilizationWindowSeconds is the number of seconds for which past recommendations should be
	// considered while scaling up or scaling down.
	// StabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).
	// If not set, use the default values:
	// - For scale up: 0 (i.e. no stabilization is done).
	// - For scale down: 300 (i.e. the stabilization window is 300 seconds long).
	// +optional
	stabilizationWindowSeconds?: int32 @protobuf(3,int32)

	// selectPolicy is used to specify which policy should be used.
	// If not set, the default value Max is used.
	// +optional
	selectPolicy?: string @protobuf(1,string)

	// policies is a list of potential scaling polices which can be used during scaling.
	// At least one policy must be specified, otherwise the HPAScalingRules will be discarded as invalid
	// +listType=atomic
	// +optional
	policies?: [...#HPAScalingPolicy] @protobuf(2,HPAScalingPolicy)
}

// HorizontalPodAutoscaler is the configuration for a horizontal pod
// autoscaler, which automatically manages the replica count of any resource
// implementing the scale subresource based on the metrics specified.
#HorizontalPodAutoscaler: {
  v1.#TypeMeta
	// metadata is the standard object metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	metadata?: v1.#ObjectMeta @protobuf(1,.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta)

	// spec is the specification for the behaviour of the autoscaler.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
	// +optional
	spec?: #HorizontalPodAutoscalerSpec @protobuf(2,HorizontalPodAutoscalerSpec)

	// status is the current information about the autoscaler.
	// +optional
	status?: #HorizontalPodAutoscalerStatus @protobuf(3,HorizontalPodAutoscalerStatus)
}

// HorizontalPodAutoscalerBehavior configures the scaling behavior of the target
// in both Up and Down directions (scaleUp and scaleDown fields respectively).
#HorizontalPodAutoscalerBehavior: {
	// scaleUp is scaling policy for scaling Up.
	// If not set, the default value is the higher of:
	//   * increase no more than 4 pods per 60 seconds
	//   * double the number of pods per 60 seconds
	// No stabilization is used.
	// +optional
	scaleUp?: #HPAScalingRules @protobuf(1,HPAScalingRules)

	// scaleDown is scaling policy for scaling Down.
	// If not set, the default value is to allow to scale down to minReplicas pods, with a
	// 300 second stabilization window (i.e., the highest recommendation for
	// the last 300sec is used).
	// +optional
	scaleDown?: #HPAScalingRules @protobuf(2,HPAScalingRules)
}

// HorizontalPodAutoscalerCondition describes the state of
// a HorizontalPodAutoscaler at a certain point.
#HorizontalPodAutoscalerCondition: {
	// type describes the current condition
	type?: string @protobuf(1,string)

	// status is the status of the condition (True, False, Unknown)
	status?: string @protobuf(2,string)

	// lastTransitionTime is the last time the condition transitioned from
	// one status to another
	// +optional
	lastTransitionTime?: v1.#Time @protobuf(3,.k8s.io.apimachinery.pkg.apis.meta.v1.Time)

	// reason is the reason for the condition's last transition.
	// +optional
	reason?: string @protobuf(4,string)

	// message is a human-readable explanation containing details about
	// the transition
	// +optional
	message?: string @protobuf(5,string)
}

// HorizontalPodAutoscalerList is a list of horizontal pod autoscaler objects.
#HorizontalPodAutoscalerList: {
	// metadata is the standard list metadata.
	// +optional
	metadata?: v1.#ListMeta @protobuf(1,.k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta)

	// items is the list of horizontal pod autoscaler objects.
	items?: [...#HorizontalPodAutoscaler] @protobuf(2,HorizontalPodAutoscaler)
}

// HorizontalPodAutoscalerSpec describes the desired functionality of the HorizontalPodAutoscaler.
#HorizontalPodAutoscalerSpec: {
	// scaleTargetRef points to the target resource to scale, and is used to the pods for which metrics
	// should be collected, as well as to actually change the replica count.
	scaleTargetRef?: #CrossVersionObjectReference @protobuf(1,CrossVersionObjectReference)

	// minReplicas is the lower limit for the number of replicas to which the autoscaler
	// can scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the
	// alpha feature gate HPAScaleToZero is enabled and at least one Object or External
	// metric is configured.  Scaling is active as long as at least one metric value is
	// available.
	// +optional
	minReplicas?: int32 @protobuf(2,int32)

	// maxReplicas is the upper limit for the number of replicas to which the autoscaler can scale up.
	// It cannot be less that minReplicas.
	maxReplicas?: int32 @protobuf(3,int32)

	// metrics contains the specifications for which to use to calculate the
	// desired replica count (the maximum replica count across all metrics will
	// be used).  The desired replica count is calculated multiplying the
	// ratio between the target value and the current value by the current
	// number of pods.  Ergo, metrics used must decrease as the pod count is
	// increased, and vice-versa.  See the individual metric source types for
	// more information about how each type of metric must respond.
	// If not set, the default metric will be set to 80% average CPU utilization.
	// +listType=atomic
	// +optional
	metrics?: [...#MetricSpec] @protobuf(4,MetricSpec)

	// behavior configures the scaling behavior of the target
	// in both Up and Down directions (scaleUp and scaleDown fields respectively).
	// If not set, the default HPAScalingRules for scale up and scale down are used.
	// +optional
	behavior?: #HorizontalPodAutoscalerBehavior @protobuf(5,HorizontalPodAutoscalerBehavior)
}

// HorizontalPodAutoscalerStatus describes the current status of a horizontal pod autoscaler.
#HorizontalPodAutoscalerStatus: {
	// observedGeneration is the most recent generation observed by this autoscaler.
	// +optional
	observedGeneration?: int64 @protobuf(1,int64)

	// lastScaleTime is the last time the HorizontalPodAutoscaler scaled the number of pods,
	// used by the autoscaler to control how often the number of pods is changed.
	// +optional
	lastScaleTime?: v1.#Time @protobuf(2,.k8s.io.apimachinery.pkg.apis.meta.v1.Time)

	// currentReplicas is current number of replicas of pods managed by this autoscaler,
	// as last seen by the autoscaler.
	// +optional
	currentReplicas?: int32 @protobuf(3,int32)

	// desiredReplicas is the desired number of replicas of pods managed by this autoscaler,
	// as last calculated by the autoscaler.
	desiredReplicas?: int32 @protobuf(4,int32)

	// currentMetrics is the last read state of the metrics used by this autoscaler.
	// +listType=atomic
	// +optional
	currentMetrics?: [...#MetricStatus] @protobuf(5,MetricStatus)

	// conditions is the set of conditions required for this autoscaler to scale its target,
	// and indicates whether or not those conditions are met.
	// +patchMergeKey=type
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=type
	// +optional
	conditions?: [...#HorizontalPodAutoscalerCondition] @protobuf(6,HorizontalPodAutoscalerCondition)
}

// MetricIdentifier defines the name and optionally selector for a metric
#MetricIdentifier: {
	// name is the name of the given metric
	name?: string @protobuf(1,string)

	// selector is the string-encoded form of a standard kubernetes label selector for the given metric
	// When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.
	// When unset, just the metricName will be used to gather metrics.
	// +optional
	selector?: v1.#LabelSelector @protobuf(2,.k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector)
}

// MetricSpec specifies how to scale based on a single metric
// (only `type` and one other matching field should be set at once).
#MetricSpec: {
	// type is the type of metric source.  It should be one of "ContainerResource", "External",
	// "Object", "Pods" or "Resource", each mapping to a matching field in the object.
	// Note: "ContainerResource" type is available on when the feature-gate
	// HPAContainerMetrics is enabled
	type?: string @protobuf(1,string)

	// object refers to a metric describing a single kubernetes object
	// (for example, hits-per-second on an Ingress object).
	// +optional
	object?: #ObjectMetricSource @protobuf(2,ObjectMetricSource)

	// pods refers to a metric describing each pod in the current scale target
	// (for example, transactions-processed-per-second).  The values will be
	// averaged together before being compared to the target value.
	// +optional
	pods?: #PodsMetricSource @protobuf(3,PodsMetricSource)

	// resource refers to a resource metric (such as those specified in
	// requests and limits) known to Kubernetes describing each pod in the
	// current scale target (e.g. CPU or memory). Such metrics are built in to
	// Kubernetes, and have special scaling options on top of those available
	// to normal per-pod metrics using the "pods" source.
	// +optional
	resource?: #ResourceMetricSource @protobuf(4,ResourceMetricSource)

	// containerResource refers to a resource metric (such as those specified in
	// requests and limits) known to Kubernetes describing a single container in
	// each pod of the current scale target (e.g. CPU or memory). Such metrics are
	// built in to Kubernetes, and have special scaling options on top of those
	// available to normal per-pod metrics using the "pods" source.
	// This is an alpha feature and can be enabled by the HPAContainerMetrics feature flag.
	// +optional
	containerResource?: #ContainerResourceMetricSource @protobuf(7,ContainerResourceMetricSource)

	// external refers to a global metric that is not associated
	// with any Kubernetes object. It allows autoscaling based on information
	// coming from components running outside of cluster
	// (for example length of queue in cloud messaging service, or
	// QPS from loadbalancer running outside of cluster).
	// +optional
	external?: #ExternalMetricSource @protobuf(5,ExternalMetricSource)
}

// MetricStatus describes the last-read state of a single metric.
#MetricStatus: {
	// type is the type of metric source.  It will be one of "ContainerResource", "External",
	// "Object", "Pods" or "Resource", each corresponds to a matching field in the object.
	// Note: "ContainerResource" type is available on when the feature-gate
	// HPAContainerMetrics is enabled
	type?: string @protobuf(1,string)

	// object refers to a metric describing a single kubernetes object
	// (for example, hits-per-second on an Ingress object).
	// +optional
	object?: #ObjectMetricStatus @protobuf(2,ObjectMetricStatus)

	// pods refers to a metric describing each pod in the current scale target
	// (for example, transactions-processed-per-second).  The values will be
	// averaged together before being compared to the target value.
	// +optional
	pods?: #PodsMetricStatus @protobuf(3,PodsMetricStatus)

	// resource refers to a resource metric (such as those specified in
	// requests and limits) known to Kubernetes describing each pod in the
	// current scale target (e.g. CPU or memory). Such metrics are built in to
	// Kubernetes, and have special scaling options on top of those available
	// to normal per-pod metrics using the "pods" source.
	// +optional
	resource?: #ResourceMetricStatus @protobuf(4,ResourceMetricStatus)

	// container resource refers to a resource metric (such as those specified in
	// requests and limits) known to Kubernetes describing a single container in each pod in the
	// current scale target (e.g. CPU or memory). Such metrics are built in to
	// Kubernetes, and have special scaling options on top of those available
	// to normal per-pod metrics using the "pods" source.
	// +optional
	containerResource?: #ContainerResourceMetricStatus @protobuf(7,ContainerResourceMetricStatus)

	// external refers to a global metric that is not associated
	// with any Kubernetes object. It allows autoscaling based on information
	// coming from components running outside of cluster
	// (for example length of queue in cloud messaging service, or
	// QPS from loadbalancer running outside of cluster).
	// +optional
	external?: #ExternalMetricStatus @protobuf(5,ExternalMetricStatus)
}

// MetricTarget defines the target value, average value, or average utilization of a specific metric
#MetricTarget: {
	// type represents whether the metric type is Utilization, Value, or AverageValue
	type?: string @protobuf(1,string)

	// value is the target value of the metric (as a quantity).
	// +optional
	value?: resource.#Quantity @protobuf(2,.k8s.io.apimachinery.pkg.api.resource.Quantity)

	// averageValue is the target value of the average of the
	// metric across all relevant pods (as a quantity)
	// +optional
	averageValue?: resource.#Quantity @protobuf(3,.k8s.io.apimachinery.pkg.api.resource.Quantity)

	// averageUtilization is the target value of the average of the
	// resource metric across all relevant pods, represented as a percentage of
	// the requested value of the resource for the pods.
	// Currently only valid for Resource metric source type
	// +optional
	averageUtilization?: int32 @protobuf(4,int32)
}

// MetricValueStatus holds the current value for a metric
#MetricValueStatus: {
	// value is the current value of the metric (as a quantity).
	// +optional
	value?: resource.#Quantity @protobuf(1,.k8s.io.apimachinery.pkg.api.resource.Quantity)

	// averageValue is the current value of the average of the
	// metric across all relevant pods (as a quantity)
	// +optional
	averageValue?: resource.#Quantity @protobuf(2,.k8s.io.apimachinery.pkg.api.resource.Quantity)

	// currentAverageUtilization is the current value of the average of the
	// resource metric across all relevant pods, represented as a percentage of
	// the requested value of the resource for the pods.
	// +optional
	averageUtilization?: int32 @protobuf(3,int32)
}

// ObjectMetricSource indicates how to scale on a metric describing a
// kubernetes object (for example, hits-per-second on an Ingress object).
#ObjectMetricSource: {
	// describedObject specifies the descriptions of a object,such as kind,name apiVersion
	describedObject?: #CrossVersionObjectReference @protobuf(1,CrossVersionObjectReference)

	// target specifies the target value for the given metric
	target?: #MetricTarget @protobuf(2,MetricTarget)

	// metric identifies the target metric by name and selector
	metric?: #MetricIdentifier @protobuf(3,MetricIdentifier)
}

// ObjectMetricStatus indicates the current value of a metric describing a
// kubernetes object (for example, hits-per-second on an Ingress object).
#ObjectMetricStatus: {
	// metric identifies the target metric by name and selector
	metric?: #MetricIdentifier @protobuf(1,MetricIdentifier)

	// current contains the current value for the given metric
	current?: #MetricValueStatus @protobuf(2,MetricValueStatus)

	// DescribedObject specifies the descriptions of a object,such as kind,name apiVersion
	describedObject?: #CrossVersionObjectReference @protobuf(3,CrossVersionObjectReference)
}

// PodsMetricSource indicates how to scale on a metric describing each pod in
// the current scale target (for example, transactions-processed-per-second).
// The values will be averaged together before being compared to the target
// value.
#PodsMetricSource: {
	// metric identifies the target metric by name and selector
	metric?: #MetricIdentifier @protobuf(1,MetricIdentifier)

	// target specifies the target value for the given metric
	target?: #MetricTarget @protobuf(2,MetricTarget)
}

// PodsMetricStatus indicates the current value of a metric describing each pod in
// the current scale target (for example, transactions-processed-per-second).
#PodsMetricStatus: {
	// metric identifies the target metric by name and selector
	metric?: #MetricIdentifier @protobuf(1,MetricIdentifier)

	// current contains the current value for the given metric
	current?: #MetricValueStatus @protobuf(2,MetricValueStatus)
}

// ResourceMetricSource indicates how to scale on a resource metric known to
// Kubernetes, as specified in requests and limits, describing each pod in the
// current scale target (e.g. CPU or memory).  The values will be averaged
// together before being compared to the target.  Such metrics are built in to
// Kubernetes, and have special scaling options on top of those available to
// normal per-pod metrics using the "pods" source.  Only one "target" type
// should be set.
#ResourceMetricSource: {
	// name is the name of the resource in question.
	name?: string @protobuf(1,string)

	// target specifies the target value for the given metric
	target?: #MetricTarget @protobuf(2,MetricTarget)
}

// ResourceMetricStatus indicates the current value of a resource metric known to
// Kubernetes, as specified in requests and limits, describing each pod in the
// current scale target (e.g. CPU or memory).  Such metrics are built in to
// Kubernetes, and have special scaling options on top of those available to
// normal per-pod metrics using the "pods" source.
#ResourceMetricStatus: {
	// name is the name of the resource in question.
	name?: string @protobuf(1,string)

	// current contains the current value for the given metric
	current?: #MetricValueStatus @protobuf(2,MetricValueStatus)
}
