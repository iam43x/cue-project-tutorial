# CUE Lang

`CUE` — это язык данных с открытым исходным кодом, основанный на логическом программировании, реализует *_механизм логического вывода_. Хотя этот язык не является языком программирования общего назначения, он решает множество задач, таких как проверка данных, создание шаблонов данных, генерация кода и даже написание скриптов.

> Механизм логического вывода — это часть системы, которая автоматически делает выводы на основе предоставленных данных и правил. Например, если вы говорите:

    Факт_1: "Все люди смертны."
    Факт_2: "Сократ — человек."
    ---
    Вывод: "Сократ смертен."

## Основные принципы и концепции

1. ### Единая модель типов и значений
    `CUE` не делает различий между значениями и типами. Значения и типы в любом порядке всегда дают один и тот же результат.

    ```go
    // user constraints
    user: {
      name: string
      age: uint8 & >18 & <128
      isActive: bool
    }
    ```
    ```go
    // user data 
    user: {
      name: "John Doe"
      age: 33
      isActive: true
    }
    ```
    ```yaml
    # output yaml
    user:
      name: "John Doe"
      age: 33
      isActive: true
    ```

    > Можно заметить сходство между CUE и JSON. Дело в том, что JSON является подмножеством CUE, т.е. любой JSON - это CUE-файл.

2. ### Обязательно используйте типы
    Типы `CUE` действуют как средства проверки данных, а также служат механизмом шаблонизации. Это мощный инструмент, но требует несколько иного мышления. При классическом подходе к наследованию типы указывают явно в месте описания структуры. Вместо этого в CUE типы указывают в месте использования.
  
    ```go
    // user type with isActive true by default
    #User: {
      name: string
      age: uint8 & >=18 & <128
      isActive: bool | *true
    }
    ```
    Достаточно указать в одном месте что все элементы списка наследуют `#User`
    ```go
    users: [...#User] // all struct is #User

    users: [
      {
        name: "John Doe"
        age: 33
      },
      {
        name: "Jane Doe"
        age: 18
        isActive: false
      }
    ]
    ```
    ```yaml
    # output yaml
    users:
      - name: "John Doe"
        age: 33
        isActive: true
      - name: "Jane Doe"
        age: 18
        isActive: false
    ```
3. ### Сложным вычислениям - простая конфигурация

    `CUE` решает конфликт между сложными вычислениями и простотой конфигурации, разделяя их. Вычисления можно выполнять вне `CUE` (например, в скриптах), а результаты — подмешивать в конфигурацию без учёта порядка. Это не только сохраняет простоту правок, но и позволяет использовать любые внешние инструменты для генерации данных.

    > Примечание: можно генерировать как в формате cue, так и yaml/json, то есть использовать форматы, которые не содержат типы и ограничения

4. ### Старт и масштабирование
    `CUE` снижает затраты на масштабирование, предлагая универсальный язык для работы с данными и/или конфигурацией на любом уровне сложности. 
    - В малых проектах он предотвращает ошибки через строгую валидацию.
    - В средних — автоматически удаляет дублирование (например, сокращая тысячи строк конфигурации).
    - В крупных — обеспечивает мощную автоматизацию благодаря математически обоснованной модели. В отличие от узкоспециализированных решений, `CUE` минимизирует необходимость перехода между инструментами), сохраняя простоту на старте и гибкость для роста.
  
5. ### Автоматизация
    Автоматизация — ключевой принцип `CUE`. 
      
      - простой парсинг
      - гибкая работа с данными из разных источников
      - независимость от порядка применения правил. 

    Это позволяет легко генерировать, анализировать и изменять конфигурации без потери предсказуемости. `CUE` специально ограничивает импорты и организует пакеты на уровне директорий, что упрощает масштабирование и автоматизацию в больших проектах.

----

Теперь, когда мы знаем о CUE, можно посмотреть на то, как будет выглядеть GitOps-репозиторий для вашего продукта, как если бы вы захотели перейти на CUE прямо сейчас.

> `GitOps` — это подход к управлению инфраструктурой `Kubernetes`, при котором желаемое состояние кластера описывается в `Git`-репозитории и автоматически синхронизируется с помощью инструментов, таких как ArgoCD или Flux. Этот метод обеспечивает прозрачность, контроль версий и возможность быстрого отката изменений, что делает развертывание более надежным и предсказуемым.

Итак, у вас уже наверняка есть какое-то количество yaml-описаний ваших объектов Kubernetes.

```bash
guestbook
├── prod
│   ├── deployment
│   │   └── guestbook.yaml
│   └── service
│       └── guestbook-svc.yaml
└── stage
    ├── deployment
    │   └── guestbook.yaml
    └── service
        └── guestbook-svc.yaml
```

Теперь предлагаю выполнить 
```bash
cd guestbook
cue import -p k8s ./... --path 'kind'  --path 'metadata.name'
find ./prod -name "*.cue" -exec sed -i '' '1s/^/if(prod)\'$'\n/' {} \; # добавляет в заголовок if(prod) для исходных файлов prod
find ./stage -name "*.cue" -exec sed -i '' '1s/^/if(stage)\'$'\n/' {} \; # добавляет в заголовок if(stage) для исходных файлов stage
```
Эта команда импортирует все ваши файлы `*.yaml` в `*.cue`

```bash
.
├── prod
│   ├── deployment
│   │   ├── guestbook.cue
│   │   └── guestbook.yaml
│   └── service
│       ├── guestbook-svc.cue
│       └── guestbook-svc.yaml
└── stage
    ├── deployment
    │   ├── guestbook.cue
    │   └── guestbook.yaml
    └── service
        ├── guestbook-svc.cue
        └── guestbook-svc.yaml
```

Далее предлагаю реорганизовать ваш проект так, чтобы каждый модуль состоял из каталога src и build, где src - исходный код ваших объектов, а build - готовые yaml

```bash
mkdir -p src/prod src/stage  # Создаем целевую структуру
mv prod/*/*.cue src/prod/  # Копируем prod
mv stage/*/*.cue src/stage/  # Копируем stage
```

Ну и перенесем наши `yaml` в `build`

```bash
mkdir build
mv prod build/
mv stage build/
```

> На этом этапе рекомендую вам закоммитить эти изменения в git, чтобы потом вы могли увидеть в чем разница между вашими yaml AS-IS и продуктом компиляции CUE. Хоть он и уверяет из коробки, что компиляция идемпотентна, я предпочитаю это контролировать + в объекты можно зашить информацию о коммите/коммиторе/дате и т.д.

Ну вот теперь можно начинать использовать `CUE` арсенал по максимуму!

Мы, когда импортировали, добавляли в --path=kind - это привело к такому результату:

```go
Deployment: guestbook: {...}
```
Вот как раз Deployment - это глобальный контейнер для всех обьектов `kind: Deployment` помним это!

Теперь нам необходимо добавить в проект этот глобальный контейнер ->

Cоздадим в корне файлик `def.cue` для всех таких контейнеров

```go
Service:    [Name=string]: {metadata: name: Name}
Deployment: [Name=string]: {metadata: name: Name}
```

Теперь можно добавить скриптов для вывода `yaml` в _stdout_ или распихать все по файликам.

`CUE` умеет импортировать схемы из исходников `golang/protobuf/..`

***НО, как показывает практика, переносится все пока не так детально как хотелось бы из-за процессов сериализации/десериализации, поэтому рекомендую всетаки просматривать получившиеся схемы глазками.

Мы в этом примере возьмем мои наработки и скопируем все из репозитория

- каталог `tool` содержит команды(скрипты в `CUE`) для работы с исходниками
- каталог `lib` содержит дефолтные значения и какие-то узкие констрейнты связанные с вашим соглашением о разработки конфигураций
- ну и вишенка на торте `cue.mod` это корневой каталог модуля `CUE` который как раз содержит пользовательские(на самом деле просто мной отредактированые продакшен) пакеты провайдеров апи такие как `Istio/Argo-CD/K8s` для валидации ваших конфигураций

> Обратите внимание как изменился def.cue в него будут добавлены lib_v1.#Deployment схемы которые в свою очередь являются расширением для исходного типа k8s.io.apps.Deployment

Также есть уже `Makefile` который любезно скрывает от пользователя/ранера сложность (и местами не очевидность) команд для cue :)

Все схемы я генерировал собрав go-зависимости в vendor оттуда достаем proto по нему сгенерировали cue для дальнейшей работы, скрипт для обновления или расширения тоже есть в Makefile

+++ плюсом там будут уже сильнее декомпозированы исходные файлы так чтобы, наглядно, была видна разница окружений для компонента

---
ПЫПЫСЫ:

Мир уже очень ускорился и далее будет только ускорятся(прогноз которого не ждали), доверяйте такие скучные задачи как валидация и проставление дефолтных параметров инструментам! Cue, на мой взгляд, имеет кучу плюсов (перечитать концепции особенно пунк про автоматизацию) чтобы стать лидером в этой нише! Помним что он потомок GCL это язык конфигурации для Borg прородителя Kubernetes.

ВСЕ!